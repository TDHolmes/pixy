; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\edgedetect.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\edgedetect.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I. -I..\libpixy -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=514 -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\spifi\edgedetect.crf edgedetect.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _Z14edgeDetect_runv PROC ; edgeDetect_run()
;;;52     
;;;53     void edgeDetect_run()
000000  b0c4              SUB      sp,sp,#0x110
;;;54     {
;;;55     	
;;;56     	int8_t retVal = 0;
000002  2000              MOVS     r0,#0
000004  9041              STR      r0,[sp,#0x104]
;;;57     	retVal += rcs_enable(1, 1);
000006  2001              MOVS     r0,#1
000008  9043              STR      r0,[sp,#0x10c]
00000a  a942              ADD      r1,sp,#0x108
00000c  9042              STR      r0,[sp,#0x108]
00000e  a843              ADD      r0,sp,#0x10c
000010  f7fffffe          BL       _Z10rcs_enableRKhS0_ ; rcs_enable(const unsigned char&, const unsigned char&)
000014  9941              LDR      r1,[sp,#0x104]
000016  4408              ADD      r0,r0,r1
000018  b240              SXTB     r0,r0
00001a  9041              STR      r0,[sp,#0x104]
;;;58     	
;;;59     	if(retVal != 0) {		// enabling error
00001c  9841              LDR      r0,[sp,#0x104]
00001e  b158              CBZ      r0,|L1.56|
;;;60     		
;;;61     		uint8_t retStr[] = "Error: Servo init";
000020  2214              MOVS     r2,#0x14
000022  a1fd              ADR      r1,|L1.1048|
000024  a812              ADD      r0,sp,#0x48
000026  f7fffffe          BL       __aeabi_memcpy4
;;;62     		UART_Send(LPC_USART0, retStr, 18, BLOCKING);
00002a  2301              MOVS     r3,#1
00002c  2212              MOVS     r2,#0x12
00002e  a912              ADD      r1,sp,#0x48
000030  48fe              LDR      r0,|L1.1068|
000032  f7fffffe          BL       UART_Send
;;;63     	}
000036  bf00              NOP      
                  |L1.56|
;;;64     	
;;;65     	uint8_t *frame = (uint8_t *)SRAM1_LOC;
000038  48fd              LDR      r0,|L1.1072|
00003a  9040              STR      r0,[sp,#0x100]
;;;66     	uint8_t *frameloc = (uint8_t *)(SRAM1_LOC + 0);
00003c  4604              MOV      r4,r0
;;;67     	uint8_t sendPositions[160];
;;;68     	uint8_t sendPositionsTwo[160];
;;;69     	uint8_t sendPositionsThree[160];
;;;70     	
;;;71     //	uint8_t floorArray[80][13];
;;;72     	
;;;73     	float theta;
;;;74     	
;;;75     	// recieve the command to get a frame
;;;76     	while(1) {
00003e  e327              B        |L1.1680|
                  |L1.64|
;;;77     		
;;;78     		
;;;79     		// red LED: Stopped waiting for data
;;;80     		led_setRGB(255, 0, 0);
000040  20ff              MOVS     r0,#0xff
000042  9016              STR      r0,[sp,#0x58]
000044  2000              MOVS     r0,#0
000046  9015              STR      r0,[sp,#0x54]
000048  aa14              ADD      r2,sp,#0x50
00004a  a915              ADD      r1,sp,#0x54
00004c  9014              STR      r0,[sp,#0x50]
00004e  a816              ADD      r0,sp,#0x58
000050  f7fffffe          BL       _Z10led_setRGBRKhS0_S0_ ; led_setRGB(const unsigned char&, const unsigned char&, const unsigned char&)
;;;81     		
;;;82     		while(1) {
000054  e00b              B        |L1.110|
                  |L1.86|
;;;83     			if(UART_DATA_AVAILABLE) {		// Data has come!
000056  48f7              LDR      r0,|L1.1076|
000058  7800              LDRB     r0,[r0,#0]  ; UART_DATA_AVAILABLE
00005a  b140              CBZ      r0,|L1.110|
;;;84     				theta = (float)UART_DATA_AVAILABLE;
00005c  48f5              LDR      r0,|L1.1076|
00005e  7800              LDRB     r0,[r0,#0]  ; UART_DATA_AVAILABLE
000060  f7fffffe          BL       __aeabi_ui2f
000064  9017              STR      r0,[sp,#0x5c]
;;;85     				UART_DATA_AVAILABLE = 0;
000066  2000              MOVS     r0,#0
000068  49f2              LDR      r1,|L1.1076|
00006a  7008              STRB     r0,[r1,#0]
;;;86     				break;
00006c  e000              B        |L1.112|
                  |L1.110|
00006e  e7f2              B        |L1.86|
                  |L1.112|
000070  bf00              NOP      
;;;87     			}
;;;88     		}
;;;89     		
;;;90     		if(theta > 42) {
000072  49f1              LDR      r1,|L1.1080|
000074  9817              LDR      r0,[sp,#0x5c]
000076  f7fffffe          BL       __aeabi_cfrcmple
00007a  d27d              BCS      |L1.376|
;;;91     			
;;;92     			uint16_t blobLen = 0;
00007c  2000              MOVS     r0,#0
00007e  9010              STR      r0,[sp,#0x40]
;;;93     			uint8_t inBlob = 0;
000080  900f              STR      r0,[sp,#0x3c]
;;;94     			uint16_t blobXPos = 0;
000082  900e              STR      r0,[sp,#0x38]
;;;95     			uint8_t count = 0;
000084  900d              STR      r0,[sp,#0x34]
;;;96     			uint8_t index = 0;
000086  900c              STR      r0,[sp,#0x30]
;;;97     			uint8_t foundEdge = 0;
000088  900b              STR      r0,[sp,#0x2c]
;;;98     			
;;;99     			// for a set angle of 12, we go to an angle of 62 degrees
;;;100    			// make sure that theta is casted as a float
;;;101    			theta = (float)(theta*(3.14159/180.0));
00008a  9817              LDR      r0,[sp,#0x5c]
00008c  f7fffffe          BL       __aeabi_f2d
000090  4605              MOV      r5,r0
000092  4aea              LDR      r2,|L1.1084|
000094  4bea              LDR      r3,|L1.1088|
000096  f7fffffe          BL       __aeabi_dmul
00009a  4607              MOV      r7,r0
00009c  f7fffffe          BL       __aeabi_d2f
0000a0  9017              STR      r0,[sp,#0x5c]
;;;102    			
;;;103    			// green LED, lets go!
;;;104    			led_setRGB(255, 255, 255);
0000a2  20ff              MOVS     r0,#0xff
0000a4  9013              STR      r0,[sp,#0x4c]
0000a6  9012              STR      r0,[sp,#0x48]
0000a8  aa11              ADD      r2,sp,#0x44
0000aa  a912              ADD      r1,sp,#0x48
0000ac  9011              STR      r0,[sp,#0x44]
0000ae  a813              ADD      r0,sp,#0x4c
0000b0  f7fffffe          BL       _Z10led_setRGBRKhS0_S0_ ; led_setRGB(const unsigned char&, const unsigned char&, const unsigned char&)
;;;105    			
;;;106    			led_setRGB(0, 0, 0);
0000b4  2000              MOVS     r0,#0
0000b6  9011              STR      r0,[sp,#0x44]
0000b8  9012              STR      r0,[sp,#0x48]
0000ba  aa13              ADD      r2,sp,#0x4c
0000bc  a912              ADD      r1,sp,#0x48
0000be  9013              STR      r0,[sp,#0x4c]
0000c0  a811              ADD      r0,sp,#0x44
0000c2  f7fffffe          BL       _Z10led_setRGBRKhS0_S0_ ; led_setRGB(const unsigned char&, const unsigned char&, const unsigned char&)
;;;107    			cam_getFrame(frameloc, SRAM1_SIZE, CAM_GRAB_M1R2, 0, 0, RES_WIDTH, RES_HEIGHT);
0000c6  20c8              MOVS     r0,#0xc8
0000c8  f44f71a0          MOV      r1,#0x140
0000cc  2200              MOVS     r2,#0
0000ce  4613              MOV      r3,r2
0000d0  e9cd2100          STRD     r2,r1,[sp,#0]
0000d4  9002              STR      r0,[sp,#8]
0000d6  2221              MOVS     r2,#0x21
0000d8  f44f3190          MOV      r1,#0x12000
0000dc  4620              MOV      r0,r4
0000de  f7fffffe          BL       _Z12cam_getFramePhjhtttt ; cam_getFrame(unsigned char*, unsigned, unsigned char, unsigned short, unsigned short, unsigned short, unsigned short)
;;;108    			led_setRGB(255, 255, 255);
0000e2  20ff              MOVS     r0,#0xff
0000e4  9011              STR      r0,[sp,#0x44]
0000e6  9012              STR      r0,[sp,#0x48]
0000e8  aa13              ADD      r2,sp,#0x4c
0000ea  a912              ADD      r1,sp,#0x48
0000ec  9013              STR      r0,[sp,#0x4c]
0000ee  a811              ADD      r0,sp,#0x44
0000f0  f7fffffe          BL       _Z10led_setRGBRKhS0_S0_ ; led_setRGB(const unsigned char&, const unsigned char&, const unsigned char&)
;;;109    			frameloc = frame;			
0000f4  9c40              LDR      r4,[sp,#0x100]
;;;110    			
;;;111    				// double for loop for calculating edges
;;;112    				for(uint16_t y = 1 + OFFSET; y < (RES_HEIGHT - OFFSET); y += 2) {
0000f6  2505              MOVS     r5,#5
0000f8  e184              B        |L1.1028|
                  |L1.250|
;;;113    					uint16_t ypo = y + 1;
0000fa  1c68              ADDS     r0,r5,#1
0000fc  fa1ff980          UXTH     r9,r0
;;;114    					uint16_t ymo = y - 1;
000100  1e68              SUBS     r0,r5,#1
000102  fa1ffa80          UXTH     r10,r0
;;;115    					
;;;116    					for(uint16_t x = 1 + OFFSET; x < (RES_WIDTH - OFFSET); x += 2) {
000106  2605              MOVS     r6,#5
000108  e170              B        |L1.1004|
                  |L1.266|
;;;117    						uint16_t xpo = x + 1;
00010a  1c70              ADDS     r0,r6,#1
00010c  b287              UXTH     r7,r0
;;;118    						uint16_t xmo = x - 1;
00010e  1e70              SUBS     r0,r6,#1
000110  fa1ff880          UXTH     r8,r0
;;;119    						
;;;120    						// Gradient/intensity calculation
;;;121    						
;;;122    						// intensity calculation for the pixel groups. each "pixel" we use is actually the intensity
;;;123    						// calculated based off of a group of four pixels. This is for speed, accuracy, and clean
;;;124    						// edges.
;;;125    
;;;126    						uint16_t intense_XPO_Y = frameloc[y*RES_WIDTH + xpo] + frameloc[ypo*RES_WIDTH + xpo+1] + 
000114  eb050185          ADD      r1,r5,r5,LSL #2
000118  eb071181          ADD      r1,r7,r1,LSL #6
00011c  5c62              LDRB     r2,[r4,r1]
00011e  eb090189          ADD      r1,r9,r9,LSL #2
000122  eb071181          ADD      r1,r7,r1,LSL #6
000126  1c49              ADDS     r1,r1,#1
000128  5c61              LDRB     r1,[r4,r1]
00012a  440a              ADD      r2,r2,r1
00012c  eb090189          ADD      r1,r9,r9,LSL #2
000130  eb071181          ADD      r1,r7,r1,LSL #6
000134  5c63              LDRB     r3,[r4,r1]
000136  eb050185          ADD      r1,r5,r5,LSL #2
00013a  eb071181          ADD      r1,r7,r1,LSL #6
00013e  1c49              ADDS     r1,r1,#1
000140  5c61              LDRB     r1,[r4,r1]
000142  1858              ADDS     r0,r3,r1
000144  eb0071d0          ADD      r1,r0,r0,LSR #31
000148  eb020161          ADD      r1,r2,r1,ASR #1
00014c  910a              STR      r1,[sp,#0x28]
;;;127    								(frameloc[ypo*RES_WIDTH + xpo] + frameloc[y*RES_WIDTH + xpo+1])/2;
;;;128    						
;;;129    						uint16_t intense_XMO_Y = frameloc[y*RES_WIDTH + xmo] + frameloc[ypo*RES_WIDTH + x] + 
00014e  eb050185          ADD      r1,r5,r5,LSL #2
000152  eb081181          ADD      r1,r8,r1,LSL #6
000156  5c61              LDRB     r1,[r4,r1]
000158  eb090289          ADD      r2,r9,r9,LSL #2
00015c  eb061282          ADD      r2,r6,r2,LSL #6
000160  5ca2              LDRB     r2,[r4,r2]
000162  4411              ADD      r1,r1,r2
000164  eb090289          ADD      r2,r9,r9,LSL #2
000168  eb081282          ADD      r2,r8,r2,LSL #6
00016c  5ca2              LDRB     r2,[r4,r2]
00016e  eb050385          ADD      r3,r5,r5,LSL #2
000172  eb061383          ADD      r3,r6,r3,LSL #6
000176  e000              B        |L1.378|
                  |L1.376|
000178  e257              B        |L1.1578|
                  |L1.378|
00017a  5ce3              LDRB     r3,[r4,r3]
00017c  18d0              ADDS     r0,r2,r3
00017e  eb0072d0          ADD      r2,r0,r0,LSR #31
000182  eb010162          ADD      r1,r1,r2,ASR #1
000186  9109              STR      r1,[sp,#0x24]
;;;130    								(frameloc[ypo*RES_WIDTH + xmo] + frameloc[y*RES_WIDTH + x])/2;
;;;131    						
;;;132    						uint16_t intense_X_YPO = frameloc[ypo*RES_WIDTH + x] + frameloc[(ypo+1)*RES_WIDTH + xpo] + 
000188  eb090189          ADD      r1,r9,r9,LSL #2
00018c  eb061181          ADD      r1,r6,r1,LSL #6
000190  5c62              LDRB     r2,[r4,r1]
000192  f1090101          ADD      r1,r9,#1
000196  eb010181          ADD      r1,r1,r1,LSL #2
00019a  eb071181          ADD      r1,r7,r1,LSL #6
00019e  5c61              LDRB     r1,[r4,r1]
0001a0  440a              ADD      r2,r2,r1
0001a2  f1090101          ADD      r1,r9,#1
0001a6  eb010181          ADD      r1,r1,r1,LSL #2
0001aa  eb061181          ADD      r1,r6,r1,LSL #6
0001ae  5c61              LDRB     r1,[r4,r1]
0001b0  eb090389          ADD      r3,r9,r9,LSL #2
0001b4  eb071383          ADD      r3,r7,r3,LSL #6
0001b8  5ce3              LDRB     r3,[r4,r3]
0001ba  18c8              ADDS     r0,r1,r3
0001bc  eb0071d0          ADD      r1,r0,r0,LSR #31
0001c0  eb020161          ADD      r1,r2,r1,ASR #1
0001c4  9108              STR      r1,[sp,#0x20]
;;;133    								(frameloc[(ypo+1)*RES_WIDTH + x] + frameloc[ypo*RES_WIDTH + xpo])/2;
;;;134    						
;;;135    						uint16_t intense_XPO_YPO = frameloc[ypo*RES_WIDTH + xpo] + frameloc[(ypo+1)*RES_WIDTH + xpo+1] + 
0001c6  eb090189          ADD      r1,r9,r9,LSL #2
0001ca  eb071181          ADD      r1,r7,r1,LSL #6
0001ce  5c62              LDRB     r2,[r4,r1]
0001d0  f1090101          ADD      r1,r9,#1
0001d4  eb010181          ADD      r1,r1,r1,LSL #2
0001d8  eb071181          ADD      r1,r7,r1,LSL #6
0001dc  1c49              ADDS     r1,r1,#1
0001de  5c61              LDRB     r1,[r4,r1]
0001e0  440a              ADD      r2,r2,r1
0001e2  f1090101          ADD      r1,r9,#1
0001e6  eb010181          ADD      r1,r1,r1,LSL #2
0001ea  eb071181          ADD      r1,r7,r1,LSL #6
0001ee  5c63              LDRB     r3,[r4,r1]
0001f0  eb090189          ADD      r1,r9,r9,LSL #2
0001f4  eb071181          ADD      r1,r7,r1,LSL #6
0001f8  1c49              ADDS     r1,r1,#1
0001fa  5c61              LDRB     r1,[r4,r1]
0001fc  1858              ADDS     r0,r3,r1
0001fe  eb0071d0          ADD      r1,r0,r0,LSR #31
000202  eb020161          ADD      r1,r2,r1,ASR #1
000206  9107              STR      r1,[sp,#0x1c]
;;;136    								(frameloc[(ypo+1)*RES_WIDTH + xpo] + frameloc[ypo*RES_WIDTH + xpo+1])/2;
;;;137    						
;;;138    						uint16_t intense_XMO_YPO = frameloc[(ypo)*RES_WIDTH + xmo] + frameloc[(ypo+1)*RES_WIDTH + x] + 
000208  eb090189          ADD      r1,r9,r9,LSL #2
00020c  eb081181          ADD      r1,r8,r1,LSL #6
000210  5c62              LDRB     r2,[r4,r1]
000212  f1090101          ADD      r1,r9,#1
000216  eb010181          ADD      r1,r1,r1,LSL #2
00021a  eb061181          ADD      r1,r6,r1,LSL #6
00021e  5c61              LDRB     r1,[r4,r1]
000220  440a              ADD      r2,r2,r1
000222  f1090101          ADD      r1,r9,#1
000226  eb010181          ADD      r1,r1,r1,LSL #2
00022a  eb081181          ADD      r1,r8,r1,LSL #6
00022e  5c61              LDRB     r1,[r4,r1]
000230  eb090389          ADD      r3,r9,r9,LSL #2
000234  eb061383          ADD      r3,r6,r3,LSL #6
000238  5ce3              LDRB     r3,[r4,r3]
00023a  18c8              ADDS     r0,r1,r3
00023c  eb0071d0          ADD      r1,r0,r0,LSR #31
000240  eb020161          ADD      r1,r2,r1,ASR #1
000244  9106              STR      r1,[sp,#0x18]
;;;139    								(frameloc[(ypo+1)*RES_WIDTH + xmo] + frameloc[ypo*RES_WIDTH + x])/2;
;;;140    						
;;;141    						uint16_t intense_X_YMO = frameloc[ymo*RES_WIDTH + x] + frameloc[y*RES_WIDTH + xpo] + 
000246  eb0a018a          ADD      r1,r10,r10,LSL #2
00024a  eb061181          ADD      r1,r6,r1,LSL #6
00024e  5c61              LDRB     r1,[r4,r1]
000250  eb050285          ADD      r2,r5,r5,LSL #2
000254  eb071282          ADD      r2,r7,r2,LSL #6
000258  5ca2              LDRB     r2,[r4,r2]
00025a  4411              ADD      r1,r1,r2
00025c  eb050285          ADD      r2,r5,r5,LSL #2
000260  eb061282          ADD      r2,r6,r2,LSL #6
000264  5ca2              LDRB     r2,[r4,r2]
000266  eb0a038a          ADD      r3,r10,r10,LSL #2
00026a  eb071383          ADD      r3,r7,r3,LSL #6
00026e  5ce3              LDRB     r3,[r4,r3]
000270  18d0              ADDS     r0,r2,r3
000272  eb0072d0          ADD      r2,r0,r0,LSR #31
000276  eb010162          ADD      r1,r1,r2,ASR #1
00027a  9105              STR      r1,[sp,#0x14]
;;;142    								(frameloc[y*RES_WIDTH + x] + frameloc[ymo*RES_WIDTH + xpo])/2;
;;;143    								
;;;144    						uint16_t intense_XPO_YMO = frameloc[ymo*RES_WIDTH + xpo] + frameloc[y*RES_WIDTH + xpo+1] + 
00027c  eb0a018a          ADD      r1,r10,r10,LSL #2
000280  eb071181          ADD      r1,r7,r1,LSL #6
000284  5c62              LDRB     r2,[r4,r1]
000286  eb050185          ADD      r1,r5,r5,LSL #2
00028a  eb071181          ADD      r1,r7,r1,LSL #6
00028e  1c49              ADDS     r1,r1,#1
000290  5c61              LDRB     r1,[r4,r1]
000292  440a              ADD      r2,r2,r1
000294  eb050185          ADD      r1,r5,r5,LSL #2
000298  eb071181          ADD      r1,r7,r1,LSL #6
00029c  5c63              LDRB     r3,[r4,r1]
00029e  eb0a018a          ADD      r1,r10,r10,LSL #2
0002a2  eb071181          ADD      r1,r7,r1,LSL #6
0002a6  1c49              ADDS     r1,r1,#1
0002a8  5c61              LDRB     r1,[r4,r1]
0002aa  1858              ADDS     r0,r3,r1
0002ac  eb0071d0          ADD      r1,r0,r0,LSR #31
0002b0  eb020161          ADD      r1,r2,r1,ASR #1
0002b4  9104              STR      r1,[sp,#0x10]
;;;145    								(frameloc[y*RES_WIDTH + xpo] + frameloc[ymo*RES_WIDTH + xpo+1])/2;
;;;146    								
;;;147    						uint16_t intense_XMO_YMO = frameloc[ymo*RES_WIDTH + xmo] + frameloc[y*RES_WIDTH + x] + 
0002b6  eb0a018a          ADD      r1,r10,r10,LSL #2
0002ba  eb081181          ADD      r1,r8,r1,LSL #6
0002be  5c61              LDRB     r1,[r4,r1]
0002c0  eb050285          ADD      r2,r5,r5,LSL #2
0002c4  eb061282          ADD      r2,r6,r2,LSL #6
0002c8  5ca2              LDRB     r2,[r4,r2]
0002ca  4411              ADD      r1,r1,r2
0002cc  eb050285          ADD      r2,r5,r5,LSL #2
0002d0  eb081282          ADD      r2,r8,r2,LSL #6
0002d4  5ca2              LDRB     r2,[r4,r2]
0002d6  eb0a038a          ADD      r3,r10,r10,LSL #2
0002da  eb061383          ADD      r3,r6,r3,LSL #6
0002de  5ce3              LDRB     r3,[r4,r3]
0002e0  18d0              ADDS     r0,r2,r3
0002e2  eb0072d0          ADD      r2,r0,r0,LSR #31
0002e6  eb010162          ADD      r1,r1,r2,ASR #1
0002ea  9103              STR      r1,[sp,#0xc]
;;;148    								(frameloc[y*RES_WIDTH + xmo] + frameloc[ymo*RES_WIDTH + x])/2;
;;;149    
;;;150    											float gradx = (3*(intense_XPO_YPO + GRAD_CO*intense_XPO_Y 
0002ec  2302              MOVS     r3,#2
0002ee  9a0a              LDR      r2,[sp,#0x28]
0002f0  9907              LDR      r1,[sp,#0x1c]
0002f2  fb131202          SMLABB   r2,r3,r2,r1
0002f6  9904              LDR      r1,[sp,#0x10]
0002f8  440a              ADD      r2,r2,r1
0002fa  9906              LDR      r1,[sp,#0x18]
0002fc  1a52              SUBS     r2,r2,r1
0002fe  9909              LDR      r1,[sp,#0x24]
000300  fb032211          MLS      r2,r3,r1,r2
000304  9903              LDR      r1,[sp,#0xc]
000306  1a51              SUBS     r1,r2,r1
000308  eb010041          ADD      r0,r1,r1,LSL #1
00030c  f7fffffe          BL       __aeabi_i2f
000310  4683              MOV      r11,r0
;;;151    						+ intense_XPO_YMO - intense_XMO_YPO 
;;;152    						- GRAD_CO*intense_XMO_Y - intense_XMO_YMO));
;;;153    							
;;;154    						float grady = (3*(intense_XMO_YMO + GRAD_CO*intense_X_YMO
000312  2302              MOVS     r3,#2
000314  9a05              LDR      r2,[sp,#0x14]
000316  9903              LDR      r1,[sp,#0xc]
000318  fb131202          SMLABB   r2,r3,r2,r1
00031c  9904              LDR      r1,[sp,#0x10]
00031e  440a              ADD      r2,r2,r1
000320  9906              LDR      r1,[sp,#0x18]
000322  1a52              SUBS     r2,r2,r1
000324  9908              LDR      r1,[sp,#0x20]
000326  fb032211          MLS      r2,r3,r1,r2
00032a  9907              LDR      r1,[sp,#0x1c]
00032c  1a51              SUBS     r1,r2,r1
00032e  eb010041          ADD      r0,r1,r1,LSL #1
000332  f7fffffe          BL       __aeabi_i2f
000336  9002              STR      r0,[sp,#8]
;;;155    							+ intense_XPO_YMO - intense_XMO_YPO 
;;;156    							- GRAD_CO*intense_X_YPO - intense_XPO_YPO));
;;;157    						
;;;158    									// Threashold detection
;;;159    						float grad = abs(gradx) + grady;
000338  4658              MOV      r0,r11
00033a  f0204100          BIC      r1,r0,#0x80000000
00033e  9100              STR      r1,[sp,#0]
000340  9902              LDR      r1,[sp,#8]
000342  9800              LDR      r0,[sp,#0]
000344  f7fffffe          BL       __aeabi_fadd
000348  9001              STR      r0,[sp,#4]
;;;160    									// Threashold detection
;;;161    					
;;;162    						if( (grad > THREASHOLD_LOW) && (gradx < THREASHOLD_HIGH) ) {
00034a  493e              LDR      r1,|L1.1092|
00034c  9801              LDR      r0,[sp,#4]
00034e  f7fffffe          BL       __aeabi_cfrcmple
000352  d20b              BCS      |L1.876|
000354  493c              LDR      r1,|L1.1096|
000356  4658              MOV      r0,r11
000358  f7fffffe          BL       __aeabi_cfcmple
00035c  d206              BCS      |L1.876|
;;;163    							// EDGE
;;;164    							frameloc[y*RES_WIDTH + x] = 255;		// sets the red pixel to max
00035e  20ff              MOVS     r0,#0xff
000360  eb050185          ADD      r1,r5,r5,LSL #2
000364  eb061181          ADD      r1,r6,r1,LSL #6
000368  5460              STRB     r0,[r4,r1]
00036a  e005              B        |L1.888|
                  |L1.876|
;;;165    						}
;;;166    						//else if(-grady > THREASHOLD_LOW && -gradx < THREASHOLD_HIGH) {
;;;167    						//	frameloc[(y+1)*RES_WIDTH + x] = 255;
;;;168    						//}
;;;169    						else {
;;;170    							// NO EDGE
;;;171    							frameloc[y*RES_WIDTH + x] = 0;			// turns off the red 
00036c  2000              MOVS     r0,#0
00036e  eb050185          ADD      r1,r5,r5,LSL #2
000372  eb061181          ADD      r1,r6,r1,LSL #6
000376  5460              STRB     r0,[r4,r1]
                  |L1.888|
;;;172    						} 
;;;173    						
;;;174    						// BLOB DETECTION
;;;175    						if(gradx > THREASHOLD_LOW) {			// if we've entered a blob (black to white transistion, going left 2 right)
000378  4932              LDR      r1,|L1.1092|
00037a  4658              MOV      r0,r11
00037c  f7fffffe          BL       __aeabi_cfrcmple
000380  d206              BCS      |L1.912|
;;;176    							inBlob = 1;
000382  2001              MOVS     r0,#1
000384  900f              STR      r0,[sp,#0x3c]
;;;177    							blobLen++;
000386  9810              LDR      r0,[sp,#0x40]
000388  1c40              ADDS     r0,r0,#1
00038a  b280              UXTH     r0,r0
00038c  9010              STR      r0,[sp,#0x40]
;;;178    							blobXPos = x;
00038e  960e              STR      r6,[sp,#0x38]
                  |L1.912|
;;;179    						}
;;;180    						if(inBlob && (-gradx < THREASHOLD_LOW)) {	// if we're in a blob and haven't reached the outer edge
000390  980f              LDR      r0,[sp,#0x3c]
000392  b150              CBZ      r0,|L1.938|
000394  f08b4000          EOR      r0,r11,#0x80000000
000398  492a              LDR      r1,|L1.1092|
00039a  9000              STR      r0,[sp,#0]
00039c  f7fffffe          BL       __aeabi_cfcmple
0003a0  d203              BCS      |L1.938|
;;;181    							blobLen++;
0003a2  9810              LDR      r0,[sp,#0x40]
0003a4  1c40              ADDS     r0,r0,#1
0003a6  b280              UXTH     r0,r0
0003a8  9010              STR      r0,[sp,#0x40]
                  |L1.938|
;;;182    						}
;;;183    						if(inBlob && (-gradx > THREASHOLD_LOW)) {	// in a blob, but exiting
0003aa  980f              LDR      r0,[sp,#0x3c]
0003ac  b1e0              CBZ      r0,|L1.1000|
0003ae  f08b4000          EOR      r0,r11,#0x80000000
0003b2  4924              LDR      r1,|L1.1092|
0003b4  9000              STR      r0,[sp,#0]
0003b6  f7fffffe          BL       __aeabi_cfrcmple
0003ba  d215              BCS      |L1.1000|
;;;184    							
;;;185    							if(blobLen < MAX_BLOB_LEN) {
0003bc  9810              LDR      r0,[sp,#0x40]
0003be  2809              CMP      r0,#9
0003c0  da0f              BGE      |L1.994|
;;;186    								frameloc[y*RES_WIDTH + blobXPos] = 0;
0003c2  2100              MOVS     r1,#0
0003c4  eb050285          ADD      r2,r5,r5,LSL #2
0003c8  980e              LDR      r0,[sp,#0x38]
0003ca  eb001082          ADD      r0,r0,r2,LSL #6
0003ce  5421              STRB     r1,[r4,r0]
;;;187    								frameloc[y*RES_WIDTH + x] = 0;
0003d0  2000              MOVS     r0,#0
0003d2  eb050185          ADD      r1,r5,r5,LSL #2
0003d6  eb061181          ADD      r1,r6,r1,LSL #6
0003da  5460              STRB     r0,[r4,r1]
;;;188    								blobLen = inBlob = 0;
0003dc  900f              STR      r0,[sp,#0x3c]
0003de  9010              STR      r0,[sp,#0x40]
0003e0  e002              B        |L1.1000|
                  |L1.994|
;;;189    							}
;;;190    							else {
;;;191    								// clear vals, no blob here
;;;192    								blobLen = inBlob = 0;
0003e2  2000              MOVS     r0,#0
0003e4  900f              STR      r0,[sp,#0x3c]
0003e6  9010              STR      r0,[sp,#0x40]
                  |L1.1000|
0003e8  1cb0              ADDS     r0,r6,#2              ;116
0003ea  b286              UXTH     r6,r0                 ;116
                  |L1.1004|
0003ec  4630              MOV      r0,r6                 ;116
0003ee  f7fffffe          BL       __aeabi_ui2d
0003f2  4607              MOV      r7,r0                 ;116
0003f4  2200              MOVS     r2,#0                 ;116
0003f6  4b15              LDR      r3,|L1.1100|
0003f8  f7fffffe          BL       __aeabi_cdcmple
0003fc  f4ffae85          BCC      |L1.266|
000400  1ca8              ADDS     r0,r5,#2              ;112
000402  b285              UXTH     r5,r0                 ;112
                  |L1.1028|
000404  4628              MOV      r0,r5                 ;112
000406  f7fffffe          BL       __aeabi_ui2d
00040a  4606              MOV      r6,r0                 ;112
00040c  2200              MOVS     r2,#0                 ;112
00040e  4b10              LDR      r3,|L1.1104|
000410  f7fffffe          BL       __aeabi_cdcmple
000414  e01e              B        |L1.1108|
000416  0000              DCW      0x0000
                  |L1.1048|
000418  4572726f          DCB      "Error: Servo init",0
00041c  723a2053
000420  6572766f
000424  20696e69
000428  7400    
00042a  00                DCB      0
00042b  00                DCB      0
                  |L1.1068|
                          DCD      0x40081000
                  |L1.1072|
                          DCD      0x10080000
                  |L1.1076|
                          DCD      UART_DATA_AVAILABLE
                  |L1.1080|
                          DCD      0x42280000
                  |L1.1084|
                          DCD      0xa50de270
                  |L1.1088|
                          DCD      0x3f91df45
                  |L1.1092|
                          DCD      0x41980000
                  |L1.1096|
                          DCD      0x47afc800
                  |L1.1100|
                          DCD      0x4073c000
                  |L1.1104|
                          DCD      0x40688000
                  |L1.1108|
000454  f4ffae51          BCC      |L1.250|
;;;193    							}
;;;194    						}
;;;195    					}
;;;196    				} // end nested for loop
;;;197    			
;;;198    				
;;;199    				// noise pixel filtering		
;;;200    
;;;201    				for(uint16_t y = 1 + OFFSET; y < (RES_HEIGHT - OFFSET); y += 2) {
000458  2505              MOVS     r5,#5
00045a  e069              B        |L1.1328|
                  |L1.1116|
;;;202    					uint16_t ypt = y + 2;
00045c  1ca8              ADDS     r0,r5,#2
00045e  fa1ff980          UXTH     r9,r0
;;;203    					uint16_t ymt = y - 2;
000462  1ea8              SUBS     r0,r5,#2
000464  fa1ffa80          UXTH     r10,r0
;;;204    				
;;;205    					for(uint16_t x = 1 + OFFSET; x < (RES_WIDTH - OFFSET); x += 2) {
000468  2605              MOVS     r6,#5
00046a  e056              B        |L1.1306|
                  |L1.1132|
;;;206    						
;;;207    						if(frameloc[y*RES_WIDTH + x] == 255) {		// if current pix. == on, check if it should be off
00046c  eb050085          ADD      r0,r5,r5,LSL #2
000470  eb061080          ADD      r0,r6,r0,LSL #6
000474  5c20              LDRB     r0,[r4,r0]
000476  28ff              CMP      r0,#0xff
000478  d14d              BNE      |L1.1302|
;;;208    							uint16_t xpt = x + 2;
00047a  1cb3              ADDS     r3,r6,#2
00047c  b299              UXTH     r1,r3
;;;209    							uint16_t xmt = x - 2;
00047e  1eb3              SUBS     r3,r6,#2
000480  b29a              UXTH     r2,r3
;;;210    							
;;;211    							uint8_t numOfPxOff = 0;
000482  2000              MOVS     r0,#0
;;;212    							
;;;213    							if(frameloc[y*RES_WIDTH + xpt] == 0) 
000484  eb050385          ADD      r3,r5,r5,LSL #2
000488  eb011383          ADD      r3,r1,r3,LSL #6
00048c  5ce3              LDRB     r3,[r4,r3]
00048e  b90b              CBNZ     r3,|L1.1172|
;;;214    								numOfPxOff++;
000490  1c43              ADDS     r3,r0,#1
000492  b2d8              UXTB     r0,r3
                  |L1.1172|
;;;215    							
;;;216    							if(frameloc[y*RES_WIDTH + xmt] == 0) 
000494  eb050385          ADD      r3,r5,r5,LSL #2
000498  eb021383          ADD      r3,r2,r3,LSL #6
00049c  5ce3              LDRB     r3,[r4,r3]
00049e  b90b              CBNZ     r3,|L1.1188|
;;;217    								numOfPxOff++;
0004a0  1c43              ADDS     r3,r0,#1
0004a2  b2d8              UXTB     r0,r3
                  |L1.1188|
;;;218    							
;;;219    							if(frameloc[(ypt)*RES_WIDTH + x] == 0) 
0004a4  eb090389          ADD      r3,r9,r9,LSL #2
0004a8  eb061383          ADD      r3,r6,r3,LSL #6
0004ac  5ce3              LDRB     r3,[r4,r3]
0004ae  b90b              CBNZ     r3,|L1.1204|
;;;220    								numOfPxOff++;
0004b0  1c43              ADDS     r3,r0,#1
0004b2  b2d8              UXTB     r0,r3
                  |L1.1204|
;;;221    							
;;;222    							if(frameloc[(ymt)*RES_WIDTH + x] == 0) 
0004b4  eb0a038a          ADD      r3,r10,r10,LSL #2
0004b8  eb061383          ADD      r3,r6,r3,LSL #6
0004bc  5ce3              LDRB     r3,[r4,r3]
0004be  b90b              CBNZ     r3,|L1.1220|
;;;223    								numOfPxOff++;
0004c0  1c43              ADDS     r3,r0,#1
0004c2  b2d8              UXTB     r0,r3
                  |L1.1220|
;;;224    							
;;;225    							if(frameloc[ymt*RES_WIDTH + xpt] == 0) 
0004c4  eb0a038a          ADD      r3,r10,r10,LSL #2
0004c8  eb011383          ADD      r3,r1,r3,LSL #6
0004cc  5ce3              LDRB     r3,[r4,r3]
0004ce  b90b              CBNZ     r3,|L1.1236|
;;;226    								numOfPxOff++;
0004d0  1c43              ADDS     r3,r0,#1
0004d2  b2d8              UXTB     r0,r3
                  |L1.1236|
;;;227    							
;;;228    							if(frameloc[ymt*RES_WIDTH + xmt] == 0) 
0004d4  eb0a038a          ADD      r3,r10,r10,LSL #2
0004d8  eb021383          ADD      r3,r2,r3,LSL #6
0004dc  5ce3              LDRB     r3,[r4,r3]
0004de  b90b              CBNZ     r3,|L1.1252|
;;;229    								numOfPxOff++;
0004e0  1c43              ADDS     r3,r0,#1
0004e2  b2d8              UXTB     r0,r3
                  |L1.1252|
;;;230    							
;;;231    							if(frameloc[(ypt)*RES_WIDTH + xpt] == 0) 
0004e4  eb090389          ADD      r3,r9,r9,LSL #2
0004e8  eb011383          ADD      r3,r1,r3,LSL #6
0004ec  5ce3              LDRB     r3,[r4,r3]
0004ee  b90b              CBNZ     r3,|L1.1268|
;;;232    								numOfPxOff++;
0004f0  1c43              ADDS     r3,r0,#1
0004f2  b2d8              UXTB     r0,r3
                  |L1.1268|
;;;233    							
;;;234    							if(frameloc[(ypt)*RES_WIDTH + xmt] == 0) 
0004f4  eb090389          ADD      r3,r9,r9,LSL #2
0004f8  eb021383          ADD      r3,r2,r3,LSL #6
0004fc  5ce3              LDRB     r3,[r4,r3]
0004fe  b90b              CBNZ     r3,|L1.1284|
;;;235    								numOfPxOff++;
000500  1c43              ADDS     r3,r0,#1
000502  b2d8              UXTB     r0,r3
                  |L1.1284|
;;;236    							
;;;237    							if(numOfPxOff > 4) {
000504  2804              CMP      r0,#4
000506  dd05              BLE      |L1.1300|
;;;238    								
;;;239    								frameloc[y*RES_WIDTH + x] = 0; 				// we only ever look at this pixel
000508  2300              MOVS     r3,#0
00050a  eb050785          ADD      r7,r5,r5,LSL #2
00050e  eb061787          ADD      r7,r6,r7,LSL #6
000512  55e3              STRB     r3,[r4,r7]
                  |L1.1300|
;;;240    							}
;;;241    							
;;;242    						} //end if(edge detected)
000514  bf00              NOP      
                  |L1.1302|
000516  1cb0              ADDS     r0,r6,#2              ;205
000518  b286              UXTH     r6,r0                 ;205
                  |L1.1306|
00051a  4630              MOV      r0,r6                 ;205
00051c  f7fffffe          BL       __aeabi_ui2d
000520  4607              MOV      r7,r0                 ;205
000522  2200              MOVS     r2,#0                 ;205
000524  4b6a              LDR      r3,|L1.1744|
000526  f7fffffe          BL       __aeabi_cdcmple
00052a  d39f              BCC      |L1.1132|
00052c  1ca8              ADDS     r0,r5,#2              ;201
00052e  b285              UXTH     r5,r0                 ;201
                  |L1.1328|
000530  4628              MOV      r0,r5                 ;201
000532  f7fffffe          BL       __aeabi_ui2d
000536  4606              MOV      r6,r0                 ;201
000538  2200              MOVS     r2,#0                 ;201
00053a  4b66              LDR      r3,|L1.1748|
00053c  f7fffffe          BL       __aeabi_cdcmple
000540  d38c              BCC      |L1.1116|
;;;243    					} // end x for
;;;244    				} // end y for
;;;245    			
;;;246    				// END NOISE FILTERING
;;;247    					
;;;248    				// front edge detection
;;;249    				
;;;250    				for( float x = 1 + GND_OFFSET_X; x < (RES_WIDTH - GND_OFFSET_X); x += 2.0) 
000542  f8df9194          LDR      r9,|L1.1752|
000546  e04d              B        |L1.1508|
                  |L1.1352|
;;;251    				{																												// start on the left
;;;252    					// float xPos;
;;;253    					
;;;254    					for( float y = (RES_HEIGHT - GND_OFFSET_Y - 1); y > GND_OFFSET_Y; y -= 2.0) 
000548  f8dfa190          LDR      r10,|L1.1756|
00054c  e02c              B        |L1.1448|
                  |L1.1358|
;;;255    					{																											// start from the bottom
;;;256    						
;;;257    						// float yPos;
;;;258    						
;;;259    						if(frameloc[((uint16_t)y)*RES_WIDTH + (uint16_t)x] != 0) {			// if the pixel is on
00054e  4648              MOV      r0,r9
000550  f7fffffe          BL       __aeabi_f2uiz
000554  b285              UXTH     r5,r0
000556  4650              MOV      r0,r10
000558  f7fffffe          BL       __aeabi_f2uiz
00055c  b280              UXTH     r0,r0
00055e  eb000080          ADD      r0,r0,r0,LSL #2
000562  eb051080          ADD      r0,r5,r0,LSL #6
000566  5c20              LDRB     r0,[r4,r0]
000568  b188              CBZ      r0,|L1.1422|
;;;260    							
;;;261    											// ACTUAL LOCATION CALCULATION
;;;262    						//	double theta_ph = atan(((2.0*y-200.0)/200.0)*TAN_FOVH_DIV_2);		// angle of the pixel
;;;263    						//	double cos_theta_ph = cos(theta_ph);											// used in the computations
;;;264    						//	double cos_theta_minus_ph = cos(theta - theta_ph);				// used in the computations
;;;265    							
;;;266    						//	yPos = ((double)((3.9)*((cos_theta_ph))))/(cos_theta_minus_ph) + 
;;;267    						//						(2.1)*tan(theta - theta_ph);		// y distance from the bot
;;;268    						//	xPos = ((yPos*(2.0*x - 320.0))/320.0)*TAN_FOVW_DIV_2;			// x distance from the bot
;;;269    							
;;;270    						//	(sendPositions + index)[2*count] = (int8_t)(xPos+128);
;;;271    						//	(sendPositions + index)[2*count + 1] = (int8_t)yPos;
;;;272    							
;;;273    							// Relative locations based on the image only
;;;274    							sendPositions[count] = (uint8_t)(200 - y);
00056a  4651              MOV      r1,r10
00056c  485c              LDR      r0,|L1.1760|
00056e  f7fffffe          BL       __aeabi_fsub
000572  4605              MOV      r5,r0
000574  f7fffffe          BL       __aeabi_f2uiz
000578  b2c1              UXTB     r1,r0
00057a  aa18              ADD      r2,sp,#0x60
00057c  980d              LDR      r0,[sp,#0x34]
00057e  5411              STRB     r1,[r2,r0]
;;;275    							count++;
000580  980d              LDR      r0,[sp,#0x34]
000582  1c40              ADDS     r0,r0,#1
000584  b2c0              UXTB     r0,r0
000586  900d              STR      r0,[sp,#0x34]
;;;276    							foundEdge = 1;
000588  2001              MOVS     r0,#1
00058a  900b              STR      r0,[sp,#0x2c]
;;;277    							break;			// stop looking for the edge, break to the next x co-ordinate
00058c  e011              B        |L1.1458|
                  |L1.1422|
00058e  4650              MOV      r0,r10                ;254
000590  f7fffffe          BL       __aeabi_f2d
000594  4607              MOV      r7,r0                 ;254
000596  2200              MOVS     r2,#0                 ;254
000598  f04f4380          MOV      r3,#0x40000000        ;254
00059c  f7fffffe          BL       __aeabi_dsub
0005a0  4605              MOV      r5,r0                 ;254
0005a2  f7fffffe          BL       __aeabi_d2f
0005a6  4682              MOV      r10,r0                ;254
                  |L1.1448|
0005a8  494e              LDR      r1,|L1.1764|
0005aa  4650              MOV      r0,r10                ;254
0005ac  f7fffffe          BL       __aeabi_cfrcmple
0005b0  d3cd              BCC      |L1.1358|
                  |L1.1458|
;;;278    						} // end if
;;;279    						
;;;280    					} // end yfor 
;;;281    					if(foundEdge == 0) {				// if we haven't stored anything in the array, store 200 and increment count.
0005b2  980b              LDR      r0,[sp,#0x2c]
0005b4  b938              CBNZ     r0,|L1.1478|
;;;282    						sendPositions[count] = (uint8_t)(200);
0005b6  21c8              MOVS     r1,#0xc8
0005b8  aa18              ADD      r2,sp,#0x60
0005ba  980d              LDR      r0,[sp,#0x34]
0005bc  5411              STRB     r1,[r2,r0]
;;;283    						count++;
0005be  980d              LDR      r0,[sp,#0x34]
0005c0  1c40              ADDS     r0,r0,#1
0005c2  b2c0              UXTB     r0,r0
0005c4  900d              STR      r0,[sp,#0x34]
                  |L1.1478|
;;;284    					}
;;;285    					foundEdge = 0;
0005c6  2000              MOVS     r0,#0
0005c8  900b              STR      r0,[sp,#0x2c]
0005ca  4648              MOV      r0,r9                 ;250
0005cc  f7fffffe          BL       __aeabi_f2d
0005d0  4607              MOV      r7,r0                 ;250
0005d2  2200              MOVS     r2,#0                 ;250
0005d4  f04f4380          MOV      r3,#0x40000000        ;250
0005d8  f7fffffe          BL       __aeabi_dadd
0005dc  4605              MOV      r5,r0                 ;250
0005de  f7fffffe          BL       __aeabi_d2f
0005e2  4681              MOV      r9,r0                 ;250
                  |L1.1508|
0005e4  4940              LDR      r1,|L1.1768|
0005e6  4648              MOV      r0,r9                 ;250
0005e8  f7fffffe          BL       __aeabi_cfcmple
0005ec  d3ac              BCC      |L1.1352|
;;;286    				} 	// end xfor
;;;287    
;;;288    				for(uint8_t i = 0; i < 160; i += 4) {
0005ee  2500              MOVS     r5,#0
0005f0  e018              B        |L1.1572|
                  |L1.1522|
;;;289    					
;;;290    					uint8_t transmitBuf = 0;
0005f2  2000              MOVS     r0,#0
0005f4  900a              STR      r0,[sp,#0x28]
;;;291    					transmitBuf = ((sendPositions[i] + sendPositions[i + 1] + sendPositions[i + 2] + 
0005f6  a818              ADD      r0,sp,#0x60
0005f8  5d41              LDRB     r1,[r0,r5]
0005fa  aa18              ADD      r2,sp,#0x60
0005fc  1c68              ADDS     r0,r5,#1
0005fe  5c10              LDRB     r0,[r2,r0]
000600  4401              ADD      r1,r1,r0
000602  1ca8              ADDS     r0,r5,#2
000604  5c10              LDRB     r0,[r2,r0]
000606  4401              ADD      r1,r1,r0
000608  1ce8              ADDS     r0,r5,#3
00060a  5c10              LDRB     r0,[r2,r0]
00060c  4408              ADD      r0,r0,r1
00060e  f3c00087          UBFX     r0,r0,#2,#8
000612  900a              STR      r0,[sp,#0x28]
;;;292    										sendPositions[i + 3]) >> 2);	// average 4 pixel y values and send
;;;293    					UART_Send(LPC_USART0, &transmitBuf, 1, BLOCKING);
000614  2301              MOVS     r3,#1
000616  461a              MOV      r2,r3
000618  a90a              ADD      r1,sp,#0x28
00061a  4834              LDR      r0,|L1.1772|
00061c  f7fffffe          BL       UART_Send
000620  1d28              ADDS     r0,r5,#4              ;288
000622  b2c5              UXTB     r5,r0                 ;288
                  |L1.1572|
000624  2da0              CMP      r5,#0xa0              ;288
000626  dbe4              BLT      |L1.1522|
;;;294    				}
;;;295    		//	UART_Send(LPC_USART0, sendPositions, 160, BLOCKING);	// sends x,y pairs!!!!
;;;296    			
;;;297    			// end front edge detection
;;;298    			
;;;299    			//if(count == 0) {					// we have not detected any edges. Oh no!
;;;300    		//		uint8_t noEdges = 42;
;;;301    		//		UART_Send(LPC_USART0, &noEdges, 1, BLOCKING); 
;;;302    		//`	}
;;;303    			
;;;304    			// UART_Send(LPC_USART0, sendPositions, 2*count, BLOCKING);	// sends x,y pairs!!!!
;;;305    			
;;;306    			
;;;307    			/////// BEGIN FLOOR PACKING//////////////////
;;;308    			
;;;309    			// we want to send out a byte packed (in the y direction) map of where we can and cannot drive.
;;;310    			// this array will have each cell (bit) represent a 2x2 cm square on the floor. We will loop through
;;;311    			// the front edge (sendPositions) array and place it in the map accordingly. First pass, we'll just
;;;312    			// add up how many fall into each block, then we will threashold that (weighted by how close the 
;;;313    			// block is to the robot) and byte pack it and send it out!
;;;314    			//
;;;315    			// the floor will be 80cm (in the y direction) by 80 cm (x direction), giving us an array of 40x40 
;;;316    			// when uncompressed and 5 by 40 when compressed (byte packed in the y direction).
;;;317    																	//  x   y
;;;318    //																	
;;;319    //			uint8_t uncompressedFloorArray[40][40];
;;;320    //			
;;;321    //			for(uint32_t x = 0; x < 40; x++) {
;;;322    //				for(uint16_t y = 0; y < 40; y++) {
;;;323    //					uncompressedFloorArray[x][y] = 0;
;;;324    //				}
;;;325    //			}
;;;326    //			
;;;327    //			// first, put the front edge in the floor array
;;;328    //			for(uint16_t i = 0; i < 2*count; i += 2) {
;;;329    //				if( ((sendPositions[i] - 128) + 40) < 80 && (sendPositions[i+1] < 80)) {
;;;330    //					
;;;331    //				  uncompressedFloorArray[((sendPositions[i] - 128) + 40) >> 1][(sendPositions[i+1] >> 1)] = 1;
;;;332    //				}
;;;333    //			}
;;;334    //			uint8_t aboveFrontEdge = 0;
;;;335    //			
;;;336    //			// a possible interum step: threasholding?
;;;337    //			
;;;338    //			// next, fill in above the front edge
;;;339    //			for(uint16_t x = 0; x < 40; x++) {
;;;340    //				for(uint16_t y = 0; y < 40; y++) {
;;;341    //					
;;;342    //					if(uncompressedFloorArray[x][y] >= 1 && !aboveFrontEdge) {	// if this square is an edge and we aren't
;;;343    //						aboveFrontEdge = 1;																	// above a front edge... 
;;;344    //					}
;;;345    //					else if(aboveFrontEdge) {									// fill the rest in
;;;346    //						uncompressedFloorArray[x][y] = 1;
;;;347    //					}
;;;348    //					
;;;349    //				} // Y for
;;;350    //				aboveFrontEdge = 0;
;;;351    //			}	// X for
;;;352    			
;;;353    			/*
;;;354    			for(uint16_t y = 0; y < 40; y++) {
;;;355    				for(uint16_t x = 0; x < 40; x++) {
;;;356    					
;;;357    					if(uncompressedFloorArray[x][y] >= 1) {
;;;358    						
;;;359    						uint8_t rxBuff = 'X';
;;;360    						UART_Send(LPC_USART0, &rxBuff, 1, BLOCKING);
;;;361    					}
;;;362    					else {
;;;363    						
;;;364    						uint8_t rxBuff = '_';
;;;365    						UART_Send(LPC_USART0, &rxBuff, 1, BLOCKING);
;;;366    					}
;;;367    			}
;;;368    				uint8_t rxBuff[] = "\n\r";
;;;369    				UART_Send(LPC_USART0, rxBuff, 2, BLOCKING);
;;;370    		}
;;;371    			*/
;;;372    			
;;;373    			// Now, byte pack into SendArray
;;;374    //			
;;;375    //			count = 0;
;;;376    //			
;;;377    //		for(uint16_t x = 0; x < 320; x++) {
;;;378    //			sendPositions[x] = 0;
;;;379    //		}
;;;380    //			
;;;381    //			for(uint16_t y = 0; y < 40; y++) {
;;;382    //				for(uint16_t x = 0; x < 40; x++) {
;;;383    //					//uint8_t mod = 1 << (y%8);
;;;384    //					//UART_Send(LPC_USART0, &mod, 1, BLOCKING);
;;;385    //					if(uncompressedFloorArray[x + y*40] == 0) {		//                  --|----- 1 is bit shifted the mod of y
;;;386    //						sendPositions[x + (y >> 3)*40] += (1 << (y%8));			//byte | 0b00100000
;;;387    //					}
;;;388    //				}
;;;389    //			}
;;;390    			
;;;391    			
;;;392    			//UART_Send(LPC_USART0, sendPositions, 200, BLOCKING);
;;;393    		 
;;;394    			
;;;395    			// Byte packing for processing script
;;;396    /*
;;;397    			for(uint16_t y = 0; y < RES_HEIGHT/2; y += 1) {
;;;398    				for (uint16_t x = 0; x < RES_WIDTH/2; x += 8) {
;;;399    
;;;400    						frameloc[y*(RES_WIDTH/16) + x/8] = (frameloc[(y*2+1)*RES_WIDTH + (2*(x+0)+1)] & 0x80) | 
;;;401    																						(frameloc[(y*2+1)*RES_WIDTH + (2*(x+1)+1)] & 0x40) |
;;;402    																						(frameloc[(y*2+1)*RES_WIDTH + (2*(x+2)+1)] & 0x20) |
;;;403    																						(frameloc[(y*2+1)*RES_WIDTH + (2*(x+3)+1)] & 0x10) |
;;;404    																						(frameloc[(y*2+1)*RES_WIDTH + (2*(x+4)+1)] & 0x08) |
;;;405    																						(frameloc[(y*2+1)*RES_WIDTH + (2*(x+5)+1)] & 0x04) |
;;;406    																						(frameloc[(y*2+1)*RES_WIDTH + (2*(x+6)+1)] & 0x02) |
;;;407    																						(frameloc[(y*2+1)*RES_WIDTH + (2*(x+7)+1)] & 0x01); 
;;;408    
;;;409    				}
;;;410    			}
;;;411    			// frame[0] = 'A';																		 // key byte
;;;412    			// UART_Send(LPC_USART0, frameloc, 2001, BLOCKING);		 // Send the frame byte packed to see it in processing
;;;413    */
;;;414    			
;;;415    		} // end edge detecting
000628  e026              B        |L1.1656|
                  |L1.1578|
;;;416    		
;;;417    		
;;;418    		
;;;419    		else if(theta > 1 ) {	// Servo move routine
00062a  f04f517e          MOV      r1,#0x3f800000
00062e  9817              LDR      r0,[sp,#0x5c]
000630  f7fffffe          BL       __aeabi_cfrcmple
000634  d214              BCS      |L1.1632|
;;;420    			uint16_t position;
;;;421    			// Move the servo based on the input from the PIC
;;;422    			// theta == 2 corrisponds to a 45 degree angle,
;;;423    			// theta == 42 corrisponds to a 135 degree angle.
;;;424    			position = theta;
000636  9817              LDR      r0,[sp,#0x5c]
000638  f7fffffe          BL       __aeabi_f2uiz
00063c  b280              UXTH     r0,r0
00063e  9012              STR      r0,[sp,#0x48]
;;;425    			position = (position - 2)*(25);
000640  f8bd0048          LDRH     r0,[sp,#0x48]
000644  1e80              SUBS     r0,r0,#2
000646  eb0001c0          ADD      r1,r0,r0,LSL #3
00064a  eb011000          ADD      r0,r1,r0,LSL #4
00064e  b280              UXTH     r0,r0
000650  9012              STR      r0,[sp,#0x48]
;;;426    			rcs_setPos(1, position);
000652  2001              MOVS     r0,#1
000654  a912              ADD      r1,sp,#0x48
000656  9013              STR      r0,[sp,#0x4c]
000658  a813              ADD      r0,sp,#0x4c
00065a  f7fffffe          BL       _Z10rcs_setPosRKhRKt ; rcs_setPos(const unsigned char&, const unsigned short&)
;;;427    		}
00065e  e00b              B        |L1.1656|
                  |L1.1632|
;;;428    		
;;;429    		else {		// theta == 1, they are asking for my ID
;;;430    			
;;;431    			// tell the processing script/pic/whatever that I am the pixy
;;;432    			uint8_t ID[] = "I am the Pixy!\n\r";
000660  2214              MOVS     r2,#0x14
000662  a123              ADR      r1,|L1.1776|
000664  a80f              ADD      r0,sp,#0x3c
000666  f7fffffe          BL       __aeabi_memcpy4
;;;433    			UART_Send(LPC_USART0, ID, 17, BLOCKING);
00066a  2301              MOVS     r3,#1
00066c  2211              MOVS     r2,#0x11
00066e  a90f              ADD      r1,sp,#0x3c
000670  481e              LDR      r0,|L1.1772|
000672  f7fffffe          BL       UART_Send
;;;434    		}
000676  bf00              NOP      
                  |L1.1656|
;;;435    	
;;;436    		led_setRGB(255, 0, 255);	// Purple LED
000678  20ff              MOVS     r0,#0xff
00067a  9014              STR      r0,[sp,#0x50]
00067c  2000              MOVS     r0,#0
00067e  9015              STR      r0,[sp,#0x54]
000680  20ff              MOVS     r0,#0xff
000682  aa16              ADD      r2,sp,#0x58
000684  a915              ADD      r1,sp,#0x54
000686  9016              STR      r0,[sp,#0x58]
000688  a814              ADD      r0,sp,#0x50
00068a  f7fffffe          BL       _Z10led_setRGBRKhS0_S0_ ; led_setRGB(const unsigned char&, const unsigned char&, const unsigned char&)
;;;437    	}
00068e  bf00              NOP      
                  |L1.1680|
000690  e4d6              B        |L1.64|
;;;438    }
;;;439    
                          ENDP

                  _Z9toggleLEDv PROC ; toggleLED()
;;;440    
;;;441    void toggleLED() {
000692  b50e              PUSH     {r1-r3,lr}
;;;442    	
;;;443    			// Toggle LED to see when we're sending frames
;;;444    
;;;445    	static uint8_t toggle = 0;
;;;446    	toggle ^= 1;
000694  481b              LDR      r0,|L1.1796|
000696  7800              LDRB     r0,[r0,#0]  ; toggle
000698  f0800001          EOR      r0,r0,#1
00069c  4919              LDR      r1,|L1.1796|
00069e  7008              STRB     r0,[r1,#0]
;;;447    	if(toggle) {
0006a0  4608              MOV      r0,r1
0006a2  7800              LDRB     r0,[r0,#0]  ; toggle
0006a4  b148              CBZ      r0,|L1.1722|
;;;448    		led_setRGB(255, 255, 255);
0006a6  20ff              MOVS     r0,#0xff
0006a8  9002              STR      r0,[sp,#8]
0006aa  9001              STR      r0,[sp,#4]
0006ac  466a              MOV      r2,sp
0006ae  a901              ADD      r1,sp,#4
0006b0  9000              STR      r0,[sp,#0]
0006b2  a802              ADD      r0,sp,#8
0006b4  f7fffffe          BL       _Z10led_setRGBRKhS0_S0_ ; led_setRGB(const unsigned char&, const unsigned char&, const unsigned char&)
;;;449    	}
0006b8  e009              B        |L1.1742|
                  |L1.1722|
;;;450    	else {
;;;451    		led_setRGB(0, 0, 0);
0006ba  2000              MOVS     r0,#0
0006bc  9002              STR      r0,[sp,#8]
0006be  9001              STR      r0,[sp,#4]
0006c0  466a              MOV      r2,sp
0006c2  a901              ADD      r1,sp,#4
0006c4  9000              STR      r0,[sp,#0]
0006c6  a802              ADD      r0,sp,#8
0006c8  f7fffffe          BL       _Z10led_setRGBRKhS0_S0_ ; led_setRGB(const unsigned char&, const unsigned char&, const unsigned char&)
;;;452    	}
0006cc  bf00              NOP      
                  |L1.1742|
;;;453    }
0006ce  bd0e              POP      {r1-r3,pc}
                          ENDP

                  |L1.1744|
                          DCD      0x4073c000
                  |L1.1748|
                          DCD      0x40688000
                  |L1.1752|
                          DCD      0x40e00000
                  |L1.1756|
                          DCD      0x433d0000
                  |L1.1760|
                          DCD      0x43480000
                  |L1.1764|
                          DCD      0x41200000
                  |L1.1768|
                          DCD      0x439d0000
                  |L1.1772|
                          DCD      0x40081000
                  |L1.1776|
0006f0  4920616d          DCB      "I am the Pixy!\n\r",0
0006f4  20746865
0006f8  20506978
0006fc  79210a0d
000700  00      
000701  00                DCB      0
000702  00                DCB      0
000703  00                DCB      0
                  |L1.1796|
                          DCD      toggle

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=0

                  toggle
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "edgedetect.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_edgedetect_cpp_d813bcf6___Z7__REV16j|
#line 130 "..\\libpixy\\core_cmInstr.h"
|__asm___14_edgedetect_cpp_d813bcf6___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_edgedetect_cpp_d813bcf6___Z7__REVSHi|
#line 144
|__asm___14_edgedetect_cpp_d813bcf6___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
